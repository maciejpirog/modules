<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Module</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Module.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption" class="empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Infered</td></tr></table><p class="caption">Module</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Right modules over monads
</a></li><li><a href="#g:2">Left modules over monads
</a></li><li><a href="#g:3">Idealised and ideal monads
</a></li></ul></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> (Functor r, Monad m) =&gt; <a href="#t:RModule">RModule</a> m r  <span class="keyword">where</span><ul class="subs"><li><a href="#v:-124--62--62--61-">(|&gt;&gt;=)</a> ::  r a -&gt; (a -&gt; m b) -&gt; r b</li></ul></li><li class="src short"><a href="#v:actr">actr</a> :: <a href="Module.html#t:RModule">RModule</a> m r =&gt; r (m a) -&gt; r a</li><li class="src short"><span class="keyword">class</span> (Functor l, Monad m) =&gt; <a href="#t:LModule">LModule</a> m l  <span class="keyword">where</span><ul class="subs"><li><a href="#v:-62--62--61--124-">(&gt;&gt;=|)</a> ::  m a -&gt; (a -&gt; l b) -&gt; l b</li></ul></li><li class="src short"><a href="#v:actl">actl</a> :: <a href="Module.html#t:LModule">LModule</a> m l =&gt; m (l a) -&gt; l a</li><li class="src short"><span class="keyword">class</span> <a href="Module.html#t:RModule">RModule</a> m r =&gt; <a href="#t:Idealised">Idealised</a> m r  <span class="keyword">where</span><ul class="subs"><li><a href="#v:embed">embed</a> ::  r a -&gt; m a</li></ul></li><li class="src short"><span class="keyword">class</span> Monad m =&gt; <a href="#t:AdjoinedUnit">AdjoinedUnit</a> m  <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:Ideal">Ideal</a> m :: * -&gt; *</li><li><a href="#v:split">split</a> ::  m a -&gt; Either a (<a href="Module.html#t:Ideal">Ideal</a> m a)</li></ul></li><li class="src short"><span class="keyword">class</span> (<a href="Module.html#t:AdjoinedUnit">AdjoinedUnit</a> m, <a href="Module.html#t:Idealised">Idealised</a> m (<a href="Module.html#t:Ideal">Ideal</a> m)) =&gt; <a href="#t:MonadIdeal">MonadIdeal</a> m </li></ul></div><div id="interface"><h1 id="g:1">Right modules over monads
</h1><div class="top"><p class="src"><span class="keyword">class</span> (Functor r, Monad m) =&gt; <a name="t:RModule" class="def">RModule</a> m r  <span class="keyword">where</span></p><div class="doc"><p>Captures the relationship of a functor being a <em>right module</em>
over a monad, which is a similar concept to modules over rings or
modules over groups (aka <em>G</em>-sets) in abstract algebra. Modules can
be seen as structures that consume monadic computations.
</p><p>Instances should satisfy the following laws:
</p><ul><li><pre>t <code><a href="Module.html#v:-124--62--62--61-">|&gt;&gt;=</a></code> <code>return</code>  =  t</pre></li><li><pre>(t <code><a href="Module.html#v:-124--62--62--61-">|&gt;&gt;=</a></code> f) <code><a href="Module.html#v:-124--62--62--61-">|&gt;&gt;=</a></code> g  =  t <code><a href="Module.html#v:-124--62--62--61-">|&gt;&gt;=</a></code> (f <code>&gt;=&gt;</code> g)</pre></li></ul></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:-124--62--62--61-" class="def">(|&gt;&gt;=)</a> ::  r a -&gt; (a -&gt; m b) -&gt; r b</p><div class="doc"><p>Bind any computation in the monad to a value of the module.
</p></div></div><div class="subs instances"><p id="control.i:RModule" class="caption collapser" onclick="toggleSection('i:RModule')">Instances</p><div id="section.i:RModule" class="show"><table><tr><td class="src"><a href="Module.html#t:RModule">RModule</a> NonEmpty <a href="Instances.html#t:AtLeast2">AtLeast2</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Functor m, Monad m) =&gt; <a href="Module.html#t:RModule">RModule</a> m (WrappedMonad m)</td><td class="doc"><p>Right regular representation
</p></td></tr><tr><td class="src"><a href="Module.html#t:RModule">RModule</a> Maybe (Const ())</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:RModule">RModule</a> Identity (Const Void)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Functor f, <a href="Module.html#t:RModule">RModule</a> m r) =&gt; <a href="Module.html#t:RModule">RModule</a> m (Compose f r)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:RModule">RModule</a> (Either e) (Const e)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Functor f =&gt; <a href="Module.html#t:RModule">RModule</a> (Free f) (<a href="Instances.html#t:Wrap">Wrap</a> f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:RModule">RModule</a> (State s) (Writer s)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:RModule">RModule</a> (Reader s) (Writer s)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n, ~ (* -&gt; *) i (<a href="IdealCoproduct.html#t:AmbiTurns">AmbiTurns</a> (<a href="Module.html#t:Ideal">Ideal</a> m) (<a href="Module.html#t:Ideal">Ideal</a> n))) =&gt; <a href="Module.html#t:RModule">RModule</a> (<a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n) i</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Functor m, <a href="Module.html#t:RModule">RModule</a> m r) =&gt; <a href="Module.html#t:RModule">RModule</a> (<a href="Resumption.html#t:Resumption">Resumption</a> m r) (<a href="Resumption.html#t:MWrap">MWrap</a> m r)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:actr" class="def">actr</a> :: <a href="Module.html#t:RModule">RModule</a> m r =&gt; r (m a) -&gt; r a</p><div class="doc"><p>Join a computation with the outer level given by a right
 module.
</p></div></div><h1 id="g:2">Left modules over monads
</h1><div class="top"><p class="src"><span class="keyword">class</span> (Functor l, Monad m) =&gt; <a name="t:LModule" class="def">LModule</a> m l  <span class="keyword">where</span></p><div class="doc"><p>Left modules are <em>op</em>-dual to right modules. Instances should satisfy the following:
</p><ul><li><pre><code>return</code> a <code><a href="Module.html#v:-62--62--61--124-">&gt;&gt;=|</a></code> f  =  f a</pre></li><li><pre>(m <code>&gt;&gt;=</code> f) <code><a href="Module.html#v:-62--62--61--124-">&gt;&gt;=|</a></code> g  =  m <code><a href="Module.html#v:-62--62--61--124-">&gt;&gt;=|</a></code> (\x -&gt; f x <code><a href="Module.html#v:-62--62--61--124-">&gt;&gt;=|</a></code> g)</pre></li></ul></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:-62--62--61--124-" class="def">(&gt;&gt;=|)</a> ::  m a -&gt; (a -&gt; l b) -&gt; l b</p><div class="doc"><p>Bind a value of the module to a monadic computation.
</p></div></div><div class="subs instances"><p id="control.i:LModule" class="caption collapser" onclick="toggleSection('i:LModule')">Instances</p><div id="section.i:LModule" class="show"><table><tr><td class="src">(Functor m, Monad m) =&gt; <a href="Module.html#t:LModule">LModule</a> m (WrappedMonad m)</td><td class="doc"><p>Left regular representation
</p></td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:actl" class="def">actl</a> :: <a href="Module.html#t:LModule">LModule</a> m l =&gt; m (l a) -&gt; l a</p><div class="doc"><p>Join a computation with the outer level given by a left
 module.
</p></div></div><h1 id="g:3">Idealised and ideal monads
</h1><div class="top"><p class="src"><span class="keyword">class</span> <a href="Module.html#t:RModule">RModule</a> m r =&gt; <a name="t:Idealised" class="def">Idealised</a> m r  <span class="keyword">where</span></p><div class="doc"><p>Captures the fact that the monad <code>m</code> is <em>idealised</em> with <code>r</code>.
This means that <code>r</code> represents a subset of computations in <code>m</code>
closed under binding with any other computation. Intuitively, <code>r</code>
contains computations with an invariant that cannot be lost by
binding more actions. For example, if we write a non-empty string
to a <code><code>Writer</code> <code>String</code></code>, we cannot obtain a writer with an empty
buffer by means of monadic composition.
</p><p>Instances should satisfy the following law:
</p><ul><li><pre><code><a href="Module.html#v:embed">embed</a></code> t <code>&gt;&gt;=</code> f  =  <code><a href="Module.html#v:embed">embed</a></code> (t <code><a href="Module.html#v:-124--62--62--61-">|&gt;&gt;=</a></code> f)</pre></li></ul></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:embed" class="def">embed</a> ::  r a -&gt; m a</p><div class="doc"><p>Represent a computation in <code>r</code> as a computation in <code>m</code>.
</p></div></div><div class="subs instances"><p id="control.i:Idealised" class="caption collapser" onclick="toggleSection('i:Idealised')">Instances</p><div id="section.i:Idealised" class="show"><table><tr><td class="src"><a href="Module.html#t:Idealised">Idealised</a> NonEmpty <a href="Instances.html#t:AtLeast2">AtLeast2</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:Idealised">Idealised</a> Maybe (Const ())</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:Idealised">Idealised</a> Identity (Const Void)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:Idealised">Idealised</a> (Either e) (Const e)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Functor f =&gt; <a href="Module.html#t:Idealised">Idealised</a> (Free f) (<a href="Instances.html#t:Wrap">Wrap</a> f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n, ~ (* -&gt; *) i (<a href="IdealCoproduct.html#t:AmbiTurns">AmbiTurns</a> (<a href="Module.html#t:Ideal">Ideal</a> m) (<a href="Module.html#t:Ideal">Ideal</a> n))) =&gt; <a href="Module.html#t:Idealised">Idealised</a> (<a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n) i</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Functor m, <a href="Module.html#t:RModule">RModule</a> m r) =&gt; <a href="Module.html#t:Idealised">Idealised</a> (<a href="Resumption.html#t:Resumption">Resumption</a> m r) (<a href="Resumption.html#t:MWrap">MWrap</a> m r)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> Monad m =&gt; <a name="t:AdjoinedUnit" class="def">AdjoinedUnit</a> m  <span class="keyword">where</span></p><div class="doc"><p>A monad with an explicit unit (that is, a computation obtained
with <code><code>return</code></code>. This class only makes sense if <code>m</code> is idealised
with <code><code><a href="Module.html#t:Ideal">Ideal</a></code> m</code>.
</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a name="t:Ideal" class="def">Ideal</a> m :: * -&gt; *</p><div class="doc"><p>Type of non-pure computations, that is, others than those
 obtained with <code><code>return</code></code>.
</p></div></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:split" class="def">split</a> ::  m a -&gt; Either a (<a href="Module.html#t:Ideal">Ideal</a> m a)</p><div class="doc"><p>Represent a monad as a disjoint sum of pure values and
 non-pure computations.
</p></div></div><div class="subs instances"><p id="control.i:AdjoinedUnit" class="caption collapser" onclick="toggleSection('i:AdjoinedUnit')">Instances</p><div id="section.i:AdjoinedUnit" class="show"><table><tr><td class="src"><a href="Module.html#t:AdjoinedUnit">AdjoinedUnit</a> Maybe</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:AdjoinedUnit">AdjoinedUnit</a> Identity</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:AdjoinedUnit">AdjoinedUnit</a> NonEmpty</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:AdjoinedUnit">AdjoinedUnit</a> (Either e)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Functor f =&gt; <a href="Module.html#t:AdjoinedUnit">AdjoinedUnit</a> (Free f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n) =&gt; <a href="Module.html#t:AdjoinedUnit">AdjoinedUnit</a> (<a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Module.html#t:AdjoinedUnit">AdjoinedUnit</a> m, <a href="Module.html#t:Idealised">Idealised</a> m (<a href="Module.html#t:Ideal">Ideal</a> m)) =&gt; <a name="t:MonadIdeal" class="def">MonadIdeal</a> m </p><div class="doc"><p>The <code><a href="Module.html#t:MonadIdeal">MonadIdeal</a></code> class is a subclass of <code>Monad</code> with the
following property: Given an ideal monad <code>m</code>, each value of <code>m a</code>
is either a pure value of the type <code>a</code> (this can be obtained with
the <code>return</code> function), or an abstract action. Moreover, a pure
value cannot be obtained by binding a non-pure action with any
other value (intuitively: once we perform an action, we cannot undo
it). More formally, a datatype <code>m a</code> is (isomorphic to) a disjoint
sum of <code>a</code> and <code>f a</code> for some functor <code>f</code>, which is called an
<em>ideal</em> of <code>m</code>. In category-theoretic terms, an ideal monad is a
semigroupad with freely adjoined unit.
</p><p>Instances should satisfy the following:
</p><ul><li><pre><code>either</code> <code>return</code> <code><a href="Module.html#v:embed">embed</a></code> . <code><a href="Module.html#v:split">split</a></code> = <code>id</code></pre></li><li><pre><code><a href="Module.html#v:split">split</a></code> . <code>either</code> <code>return</code> <code><a href="Module.html#v:embed">embed</a></code> = <code>id</code></pre></li></ul></div><div class="subs instances"><p id="control.i:MonadIdeal" class="caption collapser" onclick="toggleSection('i:MonadIdeal')">Instances</p><div id="section.i:MonadIdeal" class="show"><table><tr><td class="src"><a href="Module.html#t:MonadIdeal">MonadIdeal</a> Maybe</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:MonadIdeal">MonadIdeal</a> Identity</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:MonadIdeal">MonadIdeal</a> NonEmpty</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Module.html#t:MonadIdeal">MonadIdeal</a> (Either e)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">Functor f =&gt; <a href="Module.html#t:MonadIdeal">MonadIdeal</a> (Free f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n) =&gt; <a href="Module.html#t:MonadIdeal">MonadIdeal</a> (<a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.10.0</p></div></body></html>