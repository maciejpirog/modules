<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>IdealCoproduct</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_IdealCoproduct.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption" class="empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>maciej.adam.pirog@gmail.com</td></tr><tr><th>Safe Haskell</th><td>Safe-Infered</td></tr></table><p class="caption">IdealCoproduct</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Haskell implementation of the coproduct of two ideal monads. For
abstract nonsense, consult N. Ghani, T. Uustalu
<em>Coproducts of ideal monads</em>
<a href="http://www.cs.ioc.ee/~tarmo/papers/fics03-tia.pdf">http://www.cs.ioc.ee/~tarmo/papers/fics03-tia.pdf</a>.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">newtype</span>  <a href="#t:Turns">Turns</a> h t a = <a href="#v:Turns">Turns</a> {<ul class="subs"><li><a href="#v:unTurns">unTurns</a> :: h (Either a (<a href="IdealCoproduct.html#t:Turns">Turns</a> t h a))</li></ul>}</li><li class="src short"><span class="keyword">data</span>  <a href="#t:IdealCoproduct">IdealCoproduct</a> m n a<ul class="subs"><li>= <a href="#v:ICVar">ICVar</a> a  </li><li>| <a href="#v:ICLeft">ICLeft</a> (<a href="IdealCoproduct.html#t:Turns">Turns</a> (<a href="Module.html#t:Ideal">Ideal</a> m) (<a href="Module.html#t:Ideal">Ideal</a> n) a)  </li><li>| <a href="#v:ICRight">ICRight</a> (<a href="IdealCoproduct.html#t:Turns">Turns</a> (<a href="Module.html#t:Ideal">Ideal</a> n) (<a href="Module.html#t:Ideal">Ideal</a> m) a)  </li></ul></li><li class="src short"><a href="#v:sym">sym</a> ::  <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n a -&gt; <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> n m a</li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:AmbiTurns">AmbiTurns</a> h t a = <a href="#v:AmbiTurns">AmbiTurns</a> {<ul class="subs"><li><a href="#v:unAmbiTurns">unAmbiTurns</a> :: Either (<a href="IdealCoproduct.html#t:Turns">Turns</a> h t a) (<a href="IdealCoproduct.html#t:Turns">Turns</a> t h a)</li></ul>}</li><li class="src short"><a href="#v:liftl">liftl</a> :: (Functor (<a href="Module.html#t:Ideal">Ideal</a> m), Functor (<a href="Module.html#t:Ideal">Ideal</a> n), <a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n) =&gt; m a -&gt; <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n a</li><li class="src short"><a href="#v:liftr">liftr</a> :: (Functor (<a href="Module.html#t:Ideal">Ideal</a> m), Functor (<a href="Module.html#t:Ideal">Ideal</a> n), <a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n) =&gt; n a -&gt; <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n a</li><li class="src short"><a href="#v:foldTurns">foldTurns</a> :: (Functor h, Functor t) =&gt; (h a -&gt; a) -&gt; (t a -&gt; a) -&gt; <a href="IdealCoproduct.html#t:Turns">Turns</a> h t a -&gt; a</li><li class="src short"><a href="#v:foldIdealCoproduct">foldIdealCoproduct</a> :: (Functor (<a href="Module.html#t:Ideal">Ideal</a> m), Functor (<a href="Module.html#t:Ideal">Ideal</a> n), <a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n) =&gt; (m a -&gt; a) -&gt; (n a -&gt; a) -&gt; <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n a -&gt; a</li><li class="src short"><a href="#v:interpTurns">interpTurns</a> :: Monad k =&gt; (<span class="keyword">forall</span> a.  h a -&gt; k a) -&gt; (<span class="keyword">forall</span> a.  t a -&gt; k a) -&gt; <a href="IdealCoproduct.html#t:Turns">Turns</a> h t a -&gt; k a</li><li class="src short"><a href="#v:interpIdealCoproduct">interpIdealCoproduct</a> :: (Functor (<a href="Module.html#t:Ideal">Ideal</a> m), Functor (<a href="Module.html#t:Ideal">Ideal</a> n), <a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n, Monad k) =&gt; (<span class="keyword">forall</span> a.  m a -&gt; k a) -&gt; (<span class="keyword">forall</span> a.  n a -&gt; k a) -&gt; <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n a -&gt; k a</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:Turns" class="def">Turns</a> h t a </p><div class="doc"><p>Values of <code>Turns h t a</code> can be seen as interleaved layers of
 the functors <code>h</code> and <code>t</code> (they <em>take turns</em>) with variables of
 the type <code>a</code> possible on every level (except for the outermost
 layer, which is always given by <code>h</code>).
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Turns" class="def">Turns</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:unTurns" class="def">unTurns</a> :: h (Either a (<a href="IdealCoproduct.html#t:Turns">Turns</a> t h a))</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Turns" class="caption collapser" onclick="toggleSection('i:Turns')">Instances</p><div id="section.i:Turns" class="show"><table><tr><td class="src">(Functor t, Functor h) =&gt; Functor (<a href="IdealCoproduct.html#t:Turns">Turns</a> t h)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:IdealCoproduct" class="def">IdealCoproduct</a> m n a </p><div class="doc"><p>The coproduct (a disjoint sum in the category of ideal monads)
 of ideal monads <code>m</code> and <code>n</code>. Each value consists of alternating
 layers of the ideals of <code>m</code> and <code>n</code> with variables of the type
 <code>a</code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ICVar" class="def">ICVar</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:ICLeft" class="def">ICLeft</a> (<a href="IdealCoproduct.html#t:Turns">Turns</a> (<a href="Module.html#t:Ideal">Ideal</a> m) (<a href="Module.html#t:Ideal">Ideal</a> n) a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:ICRight" class="def">ICRight</a> (<a href="IdealCoproduct.html#t:Turns">Turns</a> (<a href="Module.html#t:Ideal">Ideal</a> n) (<a href="Module.html#t:Ideal">Ideal</a> m) a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:IdealCoproduct" class="caption collapser" onclick="toggleSection('i:IdealCoproduct')">Instances</p><div id="section.i:IdealCoproduct" class="show"><table><tr><td class="src">(<a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n) =&gt; Monad (<a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(Functor (<a href="Module.html#t:Ideal">Ideal</a> m), Functor (<a href="Module.html#t:Ideal">Ideal</a> n)) =&gt; Functor (<a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n) =&gt; Applicative (<a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n) =&gt; <a href="Module.html#t:MonadIdeal">MonadIdeal</a> (<a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n, ~ (* -&gt; *) i (<a href="IdealCoproduct.html#t:AmbiTurns">AmbiTurns</a> (<a href="Module.html#t:Ideal">Ideal</a> m) (<a href="Module.html#t:Ideal">Ideal</a> n))) =&gt; <a href="Module.html#t:Idealised">Idealised</a> (<a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n) i</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n, ~ (* -&gt; *) i (<a href="IdealCoproduct.html#t:AmbiTurns">AmbiTurns</a> (<a href="Module.html#t:Ideal">Ideal</a> m) (<a href="Module.html#t:Ideal">Ideal</a> n))) =&gt; <a href="Module.html#t:RModule">RModule</a> (<a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n) i</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:sym" class="def">sym</a> ::  <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n a -&gt; <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> n m a</p><div class="doc"><p>Swap the <code><a href="IdealCoproduct.html#v:ICLeft">ICLeft</a></code> and <code><a href="IdealCoproduct.html#v:ICRight">ICRight</a></code> constructors. The function <code><a href="IdealCoproduct.html#v:sym">sym</a></code> is an involution, that is, <code>sym . sym = id</code>.
</p></div></div><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:AmbiTurns" class="def">AmbiTurns</a> h t a </p><div class="doc"><p>The ideal of <code><a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a></code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:AmbiTurns" class="def">AmbiTurns</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:unAmbiTurns" class="def">unAmbiTurns</a> :: Either (<a href="IdealCoproduct.html#t:Turns">Turns</a> h t a) (<a href="IdealCoproduct.html#t:Turns">Turns</a> t h a)</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:AmbiTurns" class="caption collapser" onclick="toggleSection('i:AmbiTurns')">Instances</p><div id="section.i:AmbiTurns" class="show"><table><tr><td class="src">(Functor h, Functor t) =&gt; Functor (<a href="IdealCoproduct.html#t:AmbiTurns">AmbiTurns</a> h t)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:liftl" class="def">liftl</a> :: (Functor (<a href="Module.html#t:Ideal">Ideal</a> m), Functor (<a href="Module.html#t:Ideal">Ideal</a> n), <a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n) =&gt; m a -&gt; <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n a</p><div class="doc"><p>Lift an ideal monad <code>m</code> to <code>IdealCoproduct m n</code>. The function
 <code>inl</code> respects the equations of the <code>MonadTrans</code> class, that is:
</p><ul><li><pre><code><a href="IdealCoproduct.html#v:liftl">liftl</a></code> . <code>return</code>  =  <code>return</code></pre></li><li><pre><code><a href="IdealCoproduct.html#v:liftl">liftl</a></code> m <code>&gt;&gt;=</code> <code><a href="IdealCoproduct.html#v:liftl">liftl</a></code> . f  =  <code><a href="IdealCoproduct.html#v:liftl">liftl</a></code> (m <code>&gt;&gt;=</code> f)</pre></li></ul></div></div><div class="top"><p class="src"><a name="v:liftr" class="def">liftr</a> :: (Functor (<a href="Module.html#t:Ideal">Ideal</a> m), Functor (<a href="Module.html#t:Ideal">Ideal</a> n), <a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n) =&gt; n a -&gt; <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n a</p><div class="doc"><p>Symmetric version of <code><a href="IdealCoproduct.html#v:liftl">liftl</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:foldTurns" class="def">foldTurns</a> :: (Functor h, Functor t) =&gt; (h a -&gt; a) -&gt; (t a -&gt; a) -&gt; <a href="IdealCoproduct.html#t:Turns">Turns</a> h t a -&gt; a</p><div class="doc"><p>Fold the structure of a <code><a href="IdealCoproduct.html#t:Turns">Turns</a></code> using an <code>h</code>-algebra and a
 <code>t</code>-algebra.
</p></div></div><div class="top"><p class="src"><a name="v:foldIdealCoproduct" class="def">foldIdealCoproduct</a> :: (Functor (<a href="Module.html#t:Ideal">Ideal</a> m), Functor (<a href="Module.html#t:Ideal">Ideal</a> n), <a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n) =&gt; (m a -&gt; a) -&gt; (n a -&gt; a) -&gt; <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n a -&gt; a</p><div class="doc"><p>Fold the structure of an <code><a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a></code> using an <code>m</code>-algebra
 and a <code>n</code>-algebra.
</p></div></div><div class="top"><p class="src"><a name="v:interpTurns" class="def">interpTurns</a> :: Monad k =&gt; (<span class="keyword">forall</span> a.  h a -&gt; k a) -&gt; (<span class="keyword">forall</span> a.  t a -&gt; k a) -&gt; <a href="IdealCoproduct.html#t:Turns">Turns</a> h t a -&gt; k a</p><div class="doc"><p>Fold the structure of a <code><a href="IdealCoproduct.html#t:Turns">Turns</a></code> by interpreting each level as
 a computation in a monad <code>k</code> and then <code><code>join</code></code>-ing them to
 obtain one computation in <code>k</code>.
</p></div></div><div class="top"><p class="src"><a name="v:interpIdealCoproduct" class="def">interpIdealCoproduct</a> :: (Functor (<a href="Module.html#t:Ideal">Ideal</a> m), Functor (<a href="Module.html#t:Ideal">Ideal</a> n), <a href="Module.html#t:MonadIdeal">MonadIdeal</a> m, <a href="Module.html#t:MonadIdeal">MonadIdeal</a> n, Monad k) =&gt; (<span class="keyword">forall</span> a.  m a -&gt; k a) -&gt; (<span class="keyword">forall</span> a.  n a -&gt; k a) -&gt; <a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a> m n a -&gt; k a</p><div class="doc"><p>Fold the structure of an <code><a href="IdealCoproduct.html#t:IdealCoproduct">IdealCoproduct</a></code> by interpreting each
 level as a computation in a monad <code>k</code> and then <code><code>join</code></code>-ing them
 to obtain one computation in <code>k</code>.
 From the category-theoretic point of view, if the first two
 arguments are ideal monad morphisms, <code><code><a href="IdealCoproduct.html#v:interpIdealCoproduct">interpIdealCoproduct</a></code></code> is
 the coproduct mediator.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.10.0</p></div></body></html>