{-# LANGUAGE TypeFamilies, MultiParamTypeClasses, RankNTypes, DeriveFunctor, GeneralizedNewtypeDeriving #-}

{-|
Module      : Resumption
Description : Generalised resumption monad
Copyright   : (c) Maciej Piróg
License     : MIT
Maintainer  : maciej.adam.pirog@gmail.com
Stability   : experimental

Generalised resumption monad a la M. Piróg, N. Wu, J. Gibbons
/Modules over monads and their algebras/
<https://coalg.org/calco15/papers/p18-Piróg.pdf>.
-}
module Resumption
  (
    Resumption(..),
    MWrap(..),
    liftm,
    liftr,
    foldResumption,
    interpResumption
  )
  where

import Control.Applicative (Applicative(..))
import Control.Monad (ap)
import Control.Monad.Free (Free(..), iter, foldFree, liftF)

import Module
import Instances

-- | The generalised resumption monad is a composition of a monad
-- @m@ and the free monad generated by @r@ (intended to be a right
-- module over @m@).
newtype Resumption m r a =
  Resumption { unResumption :: m (Free r a) }
 deriving (Functor)

ext :: (RModule m r) => (a -> Resumption m r b) -> Free r a -> m (Free r b)
ext f (Pure a) = unResumption $ f a
ext f (Free r) = return $ Free $ r |>>= ext f

instance (RModule m r) => Monad (Resumption m r) where
  return = Resumption . return . return
  Resumption m >>= f = Resumption $ m >>= ext f

instance (Functor m, RModule m r) => Applicative (Resumption m r) where
  pure = return
  (<*>) = ap

-- | Type of resumptions with at least one level of free structure.
newtype MWrap m r a = MWrap { unMWrap :: m (Wrap r a) }
 deriving (Functor)

instance (Functor m, RModule m r) => RModule (Resumption m r) (MWrap m r) where
   MWrap m |>>= f = MWrap $
     fmap (\(Wrap r) -> Wrap $ r |>>= ext f) m

instance (Functor m, RModule m r) => Idealised (Resumption m r) (MWrap m r) where
  embed (MWrap m) = Resumption $ fmap (Free . unWrap) m

-- | Lifts a computation in a monad @m@ to a computation in the
-- resumption monad.
liftm :: (Functor m, RModule m r) => m a -> Resumption m r a
liftm = Resumption . fmap return

-- | Lifts a value of a right module over a monad @m@ to a
-- computation in the resumption monad.
liftr :: (Functor m, RModule m r) => r a -> Resumption m r a
liftr = Resumption . return . Free . fmap Pure

-- | Fold the structure of a resumption using an @m@-algebra and
-- and @r@-algebra.
foldResumption :: (Functor m, Functor r) => (m a -> a) -> (r a -> a) -> Resumption m r a -> a
foldResumption f g (Resumption m) = f $ fmap (iter g) m

-- | Fold the structure of a resumption by interpreting each layer
-- as a computation in a monad @k@ and then @'join'@-ing the
-- layers.
interpResumption :: (Functor k, Monad k) => (forall a. m a -> k a) -> (forall a. r a -> k a) -> Resumption m r a -> k a
interpResumption f g (Resumption m) = f m >>= foldFree g

-- | Unfold structure step-by-step.
unfold :: (Functor m, RModule m r) => (s -> Either a (m (r s))) -> s -> Resumption m r a
unfold f s = case f s of
               Left  a -> return a
               Right m -> (Resumption $ fmap liftF m) >>= unfold f
