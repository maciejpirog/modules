{-# LANGUAGE MultiParamTypeClasses,
             FlexibleInstances,
             FlexibleContexts,
             DeriveFunctor,
             GeneralizedNewtypeDeriving
 #-}

{-|
Module      : Control.Monad.State.AllStates.Alt
Copyright   : (c) 2015 Maciej PirÃ³g
License     : MIT
Maintainer  : maciej.adam.pirog@gmail.com
Stability   : experimental

An alternative version of the
@'Control.Monad.State.AllStates.AllStatesT'@
monad transformer defined in "Control.Monad.State.AllState".
The two monad transformers applied to @'Identity'@ yield the same
monad, but if could differ when applied to different monads.
-}
module Control.Monad.State.AllStates.Alt
  (
    -- * The @AllStatesT@ monad transformer

    AllStatesT(..),
    allToState,
    stateToAll,

    -- * The @AllStates@ monad

    AllStates,
    execAllStates
  )
  where

import Control.Applicative (Applicative, WrappedMonad(..))
import Control.Monad (liftM)
import Control.Monad.Trans (MonadTrans(..))
import Control.Monad.Identity (Identity(..))
import Control.Monad.Reader (ReaderT(..))
import Control.Monad.State (MonadState(..), StateT(..))
import Control.Monad.Free (Free(..), liftF)
import Control.Comonad.Env (EnvT(..))
import Data.Functor.Apply (Apply)
import Data.Functor.Bind (Bind)

import Control.Monad.Module.Resumption (Resumption(..), liftMonad)

-- | A monad transformer that acts like @'StateT'@, but it also
-- records every intermediate state in a stream. If the stream is
-- finite, it is terminated with the final value of type @a@.
--
-- Technically, the @'AllStatesT'@ transformer is the resumption
-- monad generated by the fact that @'EnvT' s r@ (understood as a
-- functor, not a comonad!) is a right module over @'ReaderT' s m@
-- if @r@ is a right module over @m@. This means that, modulo
-- @newtype@ constructors, it is equal to:
--
-- @
-- F m s x = (s, m x)
-- AllStatesT s m a = s -> m ('Free' (F m s) a)
-- @
--
-- Note that the stream (that is, the @'Free'@ part of the
-- datatype) could be empty
-- (e.g.
-- @'AllStatesT' $ 'Resumption' $ 'ReaderT' $ \\s -> 'return' 2@),
-- which means that the computation does not produce a new state.
-- Such a value is a pure computation.
newtype AllStatesT s m a = AllStatesT { runAllStatesT ::
  Resumption (ReaderT s m) (EnvT s (WrappedMonad m)) a }
 deriving(Functor, Applicative, Monad, Apply, Bind)

instance MonadTrans (AllStatesT s) where
  lift = AllStatesT . liftMonad . lift 

instance (Monad m) => MonadState s (AllStatesT s m) where
  get = AllStatesT $ Resumption $ ReaderT $
    \s -> return $ Pure s
  put s = AllStatesT $ Resumption $ ReaderT $
    \_ -> return $ liftF $ EnvT s $ return ()

-- | Forget the intermediate states. It is a monad morphism.
allToState :: (Monad m) => AllStatesT s m a -> StateT s m a
allToState (AllStatesT (Resumption (ReaderT r))) =
  StateT $ \s -> r s >>= aux s
 where
  aux s (Pure a)                      = return (a, s)
  aux _ (Free (EnvT s (WrapMonad m))) = m >>= aux s

-- | Lift @'StateT'@ to @'AllStatesT'@. It is NOT a monad morphism.
stateToAll :: (Monad m) => StateT s m a -> AllStatesT s m a
stateToAll (StateT f) = AllStatesT $ Resumption $ ReaderT $
  \s -> liftM (\(a,s) -> Free $ EnvT s $ return $ Pure a) (f s)

-- | A monad that acts like @'State'@, but it also records every
-- intermediate state in a (possibly infinite!) stream. If the
-- stream is finite, it is terminated with the final value.
--
-- This monad is isomorphic to
-- @'Control.Monad.State.AllStates.AllStates'@ defined in
-- "Control.Monad.State.AllStates".
type AllStates s = AllStatesT s Identity

-- | Evaluate a @'AllStates'@ computation and extract the list of
-- all intermediate states. If the computation is non-terminating,
-- the list is infinite.
execAllStates :: AllStates s a -> s -> [s]
execAllStates (AllStatesT (Resumption (ReaderT t))) s =
  fromFree $ runIdentity $ t s
 where
  fromFree (Pure _)                                       = []
  fromFree (Free (EnvT s (WrapMonad (Identity f)))) =
    s : fromFree f
