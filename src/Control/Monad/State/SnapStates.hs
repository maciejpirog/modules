{-# LANGUAGE MultiParamTypeClasses, FlexibleInstances, FlexibleContexts, DeriveFunctor, GeneralizedNewtypeDeriving #-}

{-|
Module      : Control.Monad.State.AllStates
Copyright   : (c) 2015 Maciej PirÃ³g
License     : MIT
Maintainer  : maciej.adam.pirog@gmail.com
Stability   : experimental

A monad transformer that is similar to the state monad, with the
ability to take a \"snapshot\" of the current state. Snapshots are
stored in a stream, which could be infinite, which means that it is
possible to create non-terminating stateful computations.

This transformer is similar to @'AllStates'@, but the user can
choose which states are saved.
-}
module Control.Monad.State.SnapStates
  (
    -- * The @'SnapStatesT'@ transformer

    SnapStatesT(..),
    SnapStates,
    snap,
    implant,
    stateToSnap,
    snapToState,
    execSnapStates

    -- * Examples

    -- ** While language with breakpoints
    
    -- $whileLang

  )
  where

import Control.Applicative (Applicative, WrappedMonad(..))
import Control.Monad (liftM)
import Control.Monad.Trans (MonadTrans(..))
import Control.Monad.Identity (Identity(..))
import Control.Monad.Writer (WriterT(..))
import Control.Monad.State (MonadState(..), StateT(..))
import Control.Monad.Free (Free(..), liftF)
import Data.Functor.Apply (Apply)
import Data.Functor.Bind (Bind)

import Control.Monad.Module.Resumption (Resumption(..), liftMonad)

-- | A monad transformer that acts like @'StateT'@, but it also
-- records selected intermediate states in a (possibly infinite!)
-- stream. To save the current state, use the @'snap'@ function.
-- If the stream is finite, it is terminated with the final value.
--
-- The @'SnapStatesT'@ transformer is the resumption monad
-- generated by the fact that @'WriterT' s r@ (understood as a
-- functor, not a monad!) is a right module over @'ReaderT' s m@
-- if @r@ is a right module over @m@. Modulo @newtype@
-- constructors, it is equal to:
--
-- @
-- F m s x = m (x, s)
-- AllStatesT s m a = s -> m ('Free' (F m s) a, s)
-- @
newtype SnapStatesT s m a = SnapStatesT { runAllStatesT ::
  Resumption (StateT s m) (WriterT s (WrappedMonad m)) a }
 deriving(Functor, Applicative, Monad, Apply, Bind)

type SnapStates s = SnapStatesT s Identity

instance MonadTrans (SnapStatesT s) where
  lift = SnapStatesT . liftMonad . lift 

instance (Monad m) => MonadState s (SnapStatesT s m) where
  get = stateToSnap get
  put = stateToSnap . put

-- | Take a snapshot of the current state and save it in the
-- stream.
snap :: (Monad m) => SnapStatesT s m ()
snap = SnapStatesT $ Resumption $ StateT
         $ \s -> return (Free $ WriterT $ return (Pure (), s), s)

-- | Put and snap a new state without really changing the current
-- state.
implant :: (Monad m) => s -> SnapStatesT s m ()
implant s = do { x <- get; put s; snap; put x }

-- | Lift @'StateT'@ to @'AllStatesT'@. It is a monad morphism.
stateToSnap :: (Monad m) => StateT s m a -> SnapStatesT s m a
stateToSnap = SnapStatesT . liftMonad

-- | Forget the intermediate states. It is a monad morphism.
snapToState :: (Monad m) => SnapStatesT s m a -> StateT s m a
snapToState (SnapStatesT (Resumption (StateT f))) =
  StateT $ \s -> f s >>= \(g, s') -> aux s' g
 where
  aux s (Pure a) = return (a, s)
  aux s (Free (WriterT (WrapMonad m))) = m >>= \(f, s') -> aux s' f

-- | Evaluate a @'SnapStates'@ computation and extract the list of
-- the snapped states (+ the last, not necessarily snapped state).
-- If the computation is non-terminating, the list is infinite.
execSnapStates :: SnapStates s a -> s -> [s]
execSnapStates (SnapStatesT (Resumption (StateT t))) s =
  s' : fromFree f
 where
  Identity (f, s') = t s
  fromFree (Pure _)                                       = []
  fromFree (Free (WriterT (WrapMonad (Identity (f, s))))) =
    s : fromFree f

-- | Evaluate a @'SnapStates'@ computation and extract the list of
-- the snapped states (without the last one, unless it was
-- snapped). If the computation is non-terminating, the list is
-- infinite.
snappedStates :: SnapStates s a -> s -> [s]
snappedStates (SnapStatesT (Resumption (StateT t))) s =
  case t s of
    Identity (Pure _, _) -> []
    Identity (f, s')     -> s' : fromFree f
 where
  fromFree (Free (WriterT (WrapMonad (Identity (Pure _, _))))) = []
  fromFree (Free (WriterT (WrapMonad (Identity (f, s))))) =
    s : fromFree f

--
-- EXAMPLES
--

{- $whileLang

We expand the example of the While language from the
"Control.Monad.State.AllStates". We add the ability to debug
While programs by inserting breakpoints. Whenever a breakpoint is 
encountered, the current state of memory is saved.

First, we exapnd the language with @Breakpoint@ constructor:

@
-- Type of variable identifiers
type VarId = String
\ 
-- Arithmetic expressions
data Arith = Var VarId                           -- Variable
           | C Int                               -- Constant
           | Op (Int -> Int -> Int) Arith Arith  -- Operator
\ 
-- Language statements
data Cmd = Cmd :>>: Cmd      -- Composition of programs (semicolon)
         | VarId := Arith    -- Assignment
         | If Arith Cmd Cmd  -- If statement
         | While Arith Cmd   -- While statement
         | Breakpoint        -- Breakpoint !!!
 
infixl 2 :>>:
infixl 3 :=
@

Similarly, we expand the interpreter:

@
type Memory = Map.Map VarId Int
\ 
interpA :: Arith -> SnapStates Memory Int
interpA (Var x)    = liftM (fromJust . Map.lookup x) get
interpA (C n)      = return n
interpA (Op f a b) = liftM2 f (interpA a) (interpA b)
\ 
interp :: Cmd -> SnapStates Memory ()
interp (c :>>: d)  = interp c >> interp d
interp (x := t)    = liftM2 (Map.insert x) (interpA t) get >>= put
interp (If b c d)  = do x <- interpA b
                        interp $ if x /= 0 then c else d
interp (While b c) = do x <- interpA b
                        when (x /= 0) $ interp c >> interp (While b c)
interp Breakpoint  = snap  -- !!!
@

We insert breakpoints before the loop and at the end of each
repetition:

@
fact :: Cmd
fact =
 \"x\" := C 4 :>>:
 \"total\" := C 1 :>>:
 Breakpoint :>>:  -- !!!
 While (Op (\\a b -> if a >= b then 1 else 0) (Var \"x\") (C 1))
 (
   \"total\" := Op (*) (Var \"total\") (Var \"x\") :>>:
   \"x\" := Op (-) (Var \"x\") (C 1) :>>:
   Breakpoint  -- !!!
 )
@

We run the program:

>>> snappedStates (interp fact) Map.empty
[fromList [("total",1),("x",4)],
 fromList [("total",4),("x",3)],
 fromList [("total",12),("x",2)],
 fromList [("total",24),("x",1)],
 fromList [("total",24),("x",0)]
]
-}
